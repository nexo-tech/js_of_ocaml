# Task 5.3k.1 - Remaining Work
**Date**: 2025-10-15
**Status**: COMPILATION FIXED ✅ | SWITCH FILTER INCOMPLETE ⏳

## What's Fixed

### ✅ Compilation Bug (commit 11757e37)
**Problem**: `Error: Sys_error("Invalid argument")` when compiling any file

**Root Cause**:
- `lua_of_ocaml` called `Parse_bytecode.from_exe` directly on `.cmo` files
- `from_exe` expects executables with TOC at end of file
- `.cmo` files don't have this structure → invalid seek → crash

**Fix**: Match `js_of_ocaml` behavior
```ocaml
(* Old - BROKEN *)
let one = Parse_bytecode.from_exe ~includes:... ic

(* New - FIXED *)
let kind = Parse_bytecode.from_channel ic in
match kind with
| `Exe -> Parse_bytecode.from_exe ~includes:... ic
| `Cmo _ | `Cma _ -> failwith "Cannot compile .cmo files..."
```

**Result**: Now properly rejects `.cmo` files with helpful error message

**Test**:
```bash
echo 'let () = print_endline "hello"' > test.ml
ocamlc -o test.byte test.ml
lua_of_ocaml compile test.byte -o test.lua  # Works!
lua test.lua  # Prints "hello"
```

## What's Still Broken

### ⏳ Printf Float Format Still Hangs

**Symptom**:
```bash
echo 'let () = Printf.printf "%f\n" 3.14' > test_float.ml
ocamlc -o test_float.byte test_float.ml
lua_of_ocaml compile test_float.byte -o test_float.lua
lua test_float.lua  # HANGS (infinite loop)
```

**What I Tried** (commit 11757e37):
Added filtering in `generate_last_dispatch` to remove non-existent blocks from dispatch:

```ocaml
let grouped_filtered =
  match ctx.program with
  | Some program ->
      List.filter grouped ~f:(fun (addr, _args, _indices) ->
        Code.Addr.Map.mem addr program.Code.blocks)
```

**Result of Filter**:
- ✅ Blocks 594, 595, 598-602 removed from dispatch loop
- ✅ No more `if _next_block == 594 then` cases
- ❌ STILL HANGS!

**Why It Still Hangs**:

The filter removes dispatch TARGETS but not the assignments IN block 592's Switch:

```lua
-- Block 592 dispatch case (EXISTS)
if _next_block == 592 then
  _V.v353 = _V.v359[1] or 0
  if _V.v353 == 0 then
    _next_block = 594  -- ❌ Block 594 has no dispatch case!
  else if _V.v353 == 1 then
    _next_block = 595  -- ❌ Block 595 has no dispatch case!
  ...
  else if _V.v353 == 2 or _V.v353 == 4 then
    _next_block = 601  -- ❌ Block 601 has no dispatch case!
```

After block 592 executes, `_next_block` is set to 594, 595, or 601.
The while loop continues, but finds NO matching dispatch case → infinite loop.

## The Real Problem

My filter is in the WRONG place. It filters what dispatch cases are GENERATED in the loop, but it doesn't filter what the Switch STATEMENT generates.

**Current Code Flow**:
1. `generate_last_dispatch` called on block 592's Switch terminator
2. Calls `group_by_continuation(conts)` where `conts` = array of (addr, args)
3. Filters `grouped` to remove non-existent blocks → `grouped_filtered`
4. Generates if-elseif chain from `grouped_filtered`
5. Returns the if-elseif chain as block 592's terminator code

**The Issue**: The if-elseif chain IS the Switch statement body! So my filter SHOULD work!

Let me verify: When I filter `grouped` to remove addr=594, the resulting `cases` list shouldn't have a case for index 0. But the generated code DOES have `if v353 == 0 then _next_block = 594`.

**Hypothesis**: The filter is working, but something else is generating that code. OR the grouping is weird.

## Next Steps to Debug

### 1. Add Debug Output
Add prints in `generate_last_dispatch` to see what's in `grouped` vs `grouped_filtered`:

```ocaml
(* After grouping *)
Printf.eprintf "Switch has %d groups\n" (List.length grouped);
List.iter grouped ~f:(fun (addr, _, indices) ->
  Printf.eprintf "  Group: addr=%d, indices=[%s], exists=%b\n"
    addr
    (String.concat "," (List.map ~f:string_of_int indices))
    (Code.Addr.Map.mem addr program.Code.blocks));

(* After filtering *)
Printf.eprintf "After filter: %d groups\n" (List.length grouped_filtered);
```

### 2. Check If Filter Is Called
Block 592's Switch might be generated by address-based dispatch, and `ctx.program` might be None there.

Check: Is `ctx.program` Some or None when generating block 592?

### 3. Alternative: Filter at conts Level
Instead of filtering after grouping, filter the raw `conts` array BEFORE grouping:

```ocaml
| Code.Switch (var, conts) ->
    (* Filter non-existent blocks from Switch targets *)
    let conts_filtered =
      match ctx.program with
      | None -> conts
      | Some program ->
          Array.filter conts ~f:(fun (addr, _args) ->
            Code.Addr.Map.mem addr program.Code.blocks)
    in
    (* Rest of Switch generation using conts_filtered *)
```

This would prevent non-existent blocks from ever being in the Switch at all.

### 4. Handle Empty Switch
If ALL targets are filtered out, need to handle empty Switch:
- Option A: Generate `break` (exit dispatch loop)
- Option B: Generate `error("unreachable Switch")`
- Option C: Keep one arbitrary case as fallback

## Files to Check

- `compiler/lib-lua/lua_generate.ml:2769` - Start of Switch handling
- `compiler/lib-lua/lua_generate.ml:2805-2831` - Grouping and filtering
- `compiler/lib-lua/lua_generate.ml:2853-2902` - Case generation

## Expected Fix

Once properly filtered, block 592's code should look like:

```lua
if _next_block == 592 then
  _V.v353 = _V.v359[1] or 0
  -- No cases match, fall through or break
  break  -- OR: generate error/default case
```

OR if we handle it differently:

```lua
if _next_block == 592 then
  _V.v353 = _V.v359[1] or 0
  -- Switch has no valid targets, this block is terminal
  error("Printf float format not yet supported")
```

## Test Case

```bash
echo 'let () = Printf.printf "%f\n" 3.14' > /tmp/test_float.ml
ocamlc -o /tmp/test_float.byte /tmp/test_float.ml
_build/default/compiler/bin-lua_of_ocaml/lua_of_ocaml.exe compile /tmp/test_float.byte -o /tmp/test_float.lua
timeout 3 lua /tmp/test_float.lua  # Should NOT timeout
```

Success criteria:
- Either prints a float (if we implement formatting)
- Or prints clear error about unsupported format
- But MUST NOT hang!
