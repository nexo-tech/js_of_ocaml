-- Js_of_ocaml runtime support
-- http://www.ocsigen.org/js_of_ocaml/
--
-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, with linking exception;
-- either version 2.1 of the License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

-- The pushdown automaton for parsers generated by ocamlyacc
-- Implements LR parsing with error recovery

-- Parser trace flag (for debugging)
local caml_parser_trace = false

-- Command codes for parse engine
local READ_TOKEN = 0
local RAISE_PARSE_ERROR = 1
local GROW_STACKS_1 = 2
local GROW_STACKS_2 = 3
local COMPUTE_SEMANTIC_ACTION = 4
local CALL_ERROR_FUNCTION = 5

-- Internal commands
local LOOP = 6
local TESTSHIFT = 7
local SHIFT = 8
local SHIFT_RECOVER = 9
local REDUCE = 10

-- Parser environment field indices
local ENV_S_STACK = 1           -- State stack
local ENV_V_STACK = 2           -- Value stack
local ENV_SYMB_START_STACK = 3  -- Symbol start positions
local ENV_SYMB_END_STACK = 4    -- Symbol end positions
local ENV_STACKSIZE = 5         -- Stack size
local ENV_STACKBASE = 6         -- Stack base
local ENV_CURR_CHAR = 7         -- Current token
local ENV_LVAL = 8              -- Current lexical value
local ENV_SYMB_START = 9        -- Current symbol start
local ENV_SYMB_END = 10         -- Current symbol end
local ENV_ASP = 11              -- Action stack pointer
local ENV_RULE_LEN = 12         -- Current rule length
local ENV_RULE_NUMBER = 13      -- Current rule number
local ENV_SP = 14               -- Stack pointer
local ENV_STATE = 15            -- Current state
local ENV_ERRFLAG = 16          -- Error flag

-- Parse table field indices
local TBL_ACTIONS = 1           -- Actions (not used directly)
local TBL_TRANSL_CONST = 2      -- Translation for constants
local TBL_TRANSL_BLOCK = 3      -- Translation for blocks
local TBL_LHS = 4               -- Left-hand side of rules
local TBL_LEN = 5               -- Rule lengths
local TBL_DEFRED = 6            -- Default reductions
local TBL_DGOTO = 7             -- Default goto
local TBL_SINDEX = 8            -- Shift index
local TBL_RINDEX = 9            -- Reduce index
local TBL_GINDEX = 10           -- Goto index
local TBL_TABLESIZE = 11        -- Table size
local TBL_TABLE = 12            -- Action/goto table
local TBL_CHECK = 13            -- Check table
local TBL_ERROR_FUNCTION = 14   -- Error function (not used)
local TBL_NAMES_CONST = 15      -- Token names for constants
local TBL_NAMES_BLOCK = 16      -- Token names for blocks

-- Error token code
local ERRCODE = 256

-- LR parser engine
-- tables: parse tables from ocamlyacc
-- env: parser environment
-- cmd: command to execute
-- arg: argument for command
-- Returns: command code for next step
--Provides: caml_parse_engine
--Requires: caml_lex_array
function caml_parse_engine(tables, env, cmd, arg)
  -- Parse and cache tables on first use
  if not tables.dgoto then
    tables.defred = caml_lex_array(tables[TBL_DEFRED])
    tables.sindex = caml_lex_array(tables[TBL_SINDEX])
    tables.check = caml_lex_array(tables[TBL_CHECK])
    tables.rindex = caml_lex_array(tables[TBL_RINDEX])
    tables.table = caml_lex_array(tables[TBL_TABLE])
    tables.len = caml_lex_array(tables[TBL_LEN])
    tables.lhs = caml_lex_array(tables[TBL_LHS])
    tables.gindex = caml_lex_array(tables[TBL_GINDEX])
    tables.dgoto = caml_lex_array(tables[TBL_DGOTO])
  end

  local res = 0
  local n, n1, n2, state1

  -- Restore parser state
  local sp = env[ENV_SP]
  local state = env[ENV_STATE]
  local errflag = env[ENV_ERRFLAG]

  while true do
    if cmd == 0 then  -- START
      state = 0
      errflag = 0
      cmd = LOOP
    elseif cmd == LOOP then
      n = tables.defred[state + 1]
      if n ~= 0 then
        cmd = REDUCE
        goto continue
      end
      if env[ENV_CURR_CHAR] >= 0 then
        cmd = TESTSHIFT
        goto continue
      end
      res = READ_TOKEN
      break
    elseif cmd == 1 then  -- TOKEN_READ
      -- Update current token from argument
      if type(arg) == "table" and arg.tag ~= nil then
        -- Block token (terminal with value)
        env[ENV_CURR_CHAR] = tables[TBL_TRANSL_BLOCK][arg.tag + 2]
        env[ENV_LVAL] = arg[1]
      else
        -- Constant token
        env[ENV_CURR_CHAR] = tables[TBL_TRANSL_CONST][arg + 2]
        env[ENV_LVAL] = 0
      end
      cmd = TESTSHIFT
    elseif cmd == TESTSHIFT then
      -- Try shift
      n1 = tables.sindex[state + 1]
      n2 = n1 + env[ENV_CURR_CHAR]
      if n1 ~= 0 and n2 >= 0 and n2 <= tables[TBL_TABLESIZE] and
         tables.check[n2 + 1] == env[ENV_CURR_CHAR] then
        cmd = SHIFT
        goto continue
      end

      -- Try reduce
      n1 = tables.rindex[state + 1]
      n2 = n1 + env[ENV_CURR_CHAR]
      if n1 ~= 0 and n2 >= 0 and n2 <= tables[TBL_TABLESIZE] and
         tables.check[n2 + 1] == env[ENV_CURR_CHAR] then
        n = tables.table[n2 + 1]
        cmd = REDUCE
        goto continue
      end

      -- No shift or reduce: error
      if errflag <= 0 then
        res = CALL_ERROR_FUNCTION
        break
      end
      cmd = 5  -- ERROR_DETECTED
    elseif cmd == 5 then  -- ERROR_DETECTED
      if errflag < 3 then
        errflag = 3
        -- Pop states until we find one that can shift ERRCODE
        while true do
          state1 = env[ENV_S_STACK][sp + 1]
          n1 = tables.sindex[state1 + 1]
          n2 = n1 + ERRCODE
          if n1 ~= 0 and n2 >= 0 and n2 <= tables[TBL_TABLESIZE] and
             tables.check[n2 + 1] == ERRCODE then
            cmd = SHIFT_RECOVER
            goto continue
          else
            if sp <= env[ENV_STACKBASE] then
              -- Save state before returning
              env[ENV_SP] = sp
              env[ENV_STATE] = state
              env[ENV_ERRFLAG] = errflag
              return RAISE_PARSE_ERROR
            end
            sp = sp - 1
          end
        end
      else
        -- Discard token
        if env[ENV_CURR_CHAR] == 0 then
          env[ENV_SP] = sp
          env[ENV_STATE] = state
          env[ENV_ERRFLAG] = errflag
          return RAISE_PARSE_ERROR
        end
        env[ENV_CURR_CHAR] = -1
        cmd = LOOP
        goto continue
      end
    elseif cmd == SHIFT then
      env[ENV_CURR_CHAR] = -1
      if errflag > 0 then
        errflag = errflag - 1
      end
      cmd = SHIFT_RECOVER
    elseif cmd == SHIFT_RECOVER then
      state = tables.table[n2 + 1]
      sp = sp + 1
      if sp >= env[ENV_STACKSIZE] then
        res = GROW_STACKS_1
        break
      end
      cmd = 2  -- STACKS_GROWN_1
    elseif cmd == 2 then  -- STACKS_GROWN_1
      env[ENV_S_STACK][sp + 1] = state
      env[ENV_V_STACK][sp + 1] = env[ENV_LVAL]
      env[ENV_SYMB_START_STACK][sp + 1] = env[ENV_SYMB_START]
      env[ENV_SYMB_END_STACK][sp + 1] = env[ENV_SYMB_END]
      cmd = LOOP
      goto continue
    elseif cmd == REDUCE then
      local m = tables.len[n + 1]
      env[ENV_ASP] = sp
      env[ENV_RULE_NUMBER] = n
      env[ENV_RULE_LEN] = m
      sp = sp - m + 1
      m = tables.lhs[n + 1]
      state1 = env[ENV_S_STACK][sp + 1]
      n1 = tables.gindex[m + 1]
      n2 = n1 + state1
      if n1 ~= 0 and n2 >= 0 and n2 <= tables[TBL_TABLESIZE] and
         tables.check[n2 + 1] == state1 then
        state = tables.table[n2 + 1]
      else
        state = tables.dgoto[m + 1]
      end
      if sp >= env[ENV_STACKSIZE] then
        res = GROW_STACKS_2
        break
      end
      cmd = 3  -- STACKS_GROWN_2
    elseif cmd == 3 then  -- STACKS_GROWN_2
      res = COMPUTE_SEMANTIC_ACTION
      break
    elseif cmd == 4 then  -- SEMANTIC_ACTION_COMPUTED
      env[ENV_S_STACK][sp + 1] = state
      env[ENV_V_STACK][sp + 1] = arg
      local asp = env[ENV_ASP]
      env[ENV_SYMB_END_STACK][sp + 1] = env[ENV_SYMB_END_STACK][asp + 1]
      if sp > asp then
        -- Epsilon production: take symb_start equal to symb_end
        env[ENV_SYMB_START_STACK][sp + 1] = env[ENV_SYMB_END_STACK][asp + 1]
      end
      cmd = LOOP
      goto continue
    else
      -- Unknown command
      env[ENV_SP] = sp
      env[ENV_STATE] = state
      env[ENV_ERRFLAG] = errflag
      return RAISE_PARSE_ERROR
    end

    ::continue::
  end

  -- Save parser state
  env[ENV_SP] = sp
  env[ENV_STATE] = state
  env[ENV_ERRFLAG] = errflag
  return res
end

-- Set parser trace flag
-- bool: true to enable, false to disable
-- Returns: old flag value
--Provides: caml_set_parser_trace
function caml_set_parser_trace(bool)
  local oldflag = caml_parser_trace
  caml_parser_trace = bool
  return oldflag
end

-- Create a parser environment
-- stacksize: initial stack size
-- Returns: parser environment
--Provides: caml_create_parser_env
function caml_create_parser_env(stacksize)
  local size = stacksize or 100

  local env = {
    [ENV_S_STACK] = {},
    [ENV_V_STACK] = {},
    [ENV_SYMB_START_STACK] = {},
    [ENV_SYMB_END_STACK] = {},
    [ENV_STACKSIZE] = size,
    [ENV_STACKBASE] = 0,
    [ENV_CURR_CHAR] = -1,
    [ENV_LVAL] = 0,
    [ENV_SYMB_START] = 0,
    [ENV_SYMB_END] = 0,
    [ENV_ASP] = 0,
    [ENV_RULE_LEN] = 0,
    [ENV_RULE_NUMBER] = 0,
    [ENV_SP] = 0,
    [ENV_STATE] = 0,
    [ENV_ERRFLAG] = 0,
  }

  return env
end

-- Grow parser stacks
-- env: parser environment
-- new_size: new stack size
--Provides: caml_grow_parser_stacks
function caml_grow_parser_stacks(env, new_size)
  env[ENV_STACKSIZE] = new_size
  -- Stacks grow automatically in Lua, no need to resize
end

-- Get current rule information
-- env: parser environment
-- Returns: rule_number, rule_len
--Provides: caml_parser_rule_info
function caml_parser_rule_info(env)
  return env[ENV_RULE_NUMBER], env[ENV_RULE_LEN]
end

-- Get stack value at offset from action stack pointer
-- env: parser environment
-- offset: offset from asp (0 = top of matched rule)
-- Returns: value
--Provides: caml_parser_stack_value
function caml_parser_stack_value(env, offset)
  local asp = env[ENV_ASP]
  return env[ENV_V_STACK][asp + offset + 1]
end

-- Get symbol start position at offset
-- env: parser environment
-- offset: offset from asp
-- Returns: position
--Provides: caml_parser_symb_start
function caml_parser_symb_start(env, offset)
  local asp = env[ENV_ASP]
  return env[ENV_SYMB_START_STACK][asp + offset + 1]
end

-- Get symbol end position at offset
-- env: parser environment
-- offset: offset from asp
-- Returns: position
--Provides: caml_parser_symb_end
function caml_parser_symb_end(env, offset)
  local asp = env[ENV_ASP]
  return env[ENV_SYMB_END_STACK][asp + offset + 1]
end
