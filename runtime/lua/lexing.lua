-- Js_of_ocaml runtime support
-- http://www.ocsigen.org/js_of_ocaml/
--
-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, with linking exception;
-- either version 2.1 of the License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

-- Table-driven automaton for lexers generated by ocamllex
-- Implements DFA-based lexical analysis with position tracking

-- Lexbuf field indices (must match OCaml runtime layout)
local LEX_REFILL_BUF = 1
local LEX_BUFFER = 2
local LEX_BUFFER_LEN = 3
local LEX_ABS_POS = 4
local LEX_START_POS = 5
local LEX_CURR_POS = 6
local LEX_LAST_POS = 7
local LEX_LAST_ACTION = 8
local LEX_EOF_REACHED = 9
local LEX_MEM = 10
local LEX_START_P = 11
local LEX_CURR_P = 12

-- Table field indices
local TBL_BASE = 1
local TBL_BACKTRK = 2
local TBL_DEFAULT = 3
local TBL_TRANS = 4
local TBL_CHECK = 5

-- Convert OCaml string (packed as 16-bit values) to array
--Provides: caml_lex_array
function caml_lex_array(s)
  local len = #s / 2
  local result = {}

  for i = 0, len - 1 do
    local lo = s[2 * i + 1]
    local hi = s[2 * i + 2]
    -- Pack as signed 16-bit value
    local val = lo | (hi << 8)
    -- Sign extend from 16 to 32 bits
    if val >= 0x8000 then
      val = val - 0x10000
    end
    result[i + 1] = val
  end

  return result
end

-- DFA-based lexer engine
-- tbl: transition table
-- start_state: initial state
-- lexbuf: lexer buffer
-- Returns: action number
--Provides: caml_lex_engine
--Requires: caml_lex_array
function caml_lex_engine(tbl, start_state, lexbuf)
  -- Parse and cache transition tables on first use
  if not tbl.lex_default then
    tbl.lex_base = caml_lex_array(tbl[TBL_BASE])
    tbl.lex_backtrk = caml_lex_array(tbl[TBL_BACKTRK])
    tbl.lex_check = caml_lex_array(tbl[TBL_CHECK])
    tbl.lex_trans = caml_lex_array(tbl[TBL_TRANS])
    tbl.lex_default = caml_lex_array(tbl[TBL_DEFAULT])
  end

  local state = start_state
  local buffer = lexbuf[LEX_BUFFER]

  if state >= 0 then
    -- First entry
    lexbuf[LEX_LAST_POS] = lexbuf[LEX_CURR_POS]
    lexbuf[LEX_START_POS] = lexbuf[LEX_CURR_POS]
    lexbuf[LEX_LAST_ACTION] = -1
  else
    -- Reentry after refill
    state = -state - 1
  end

  while true do
    -- Lookup base address or action number for current state
    local base = tbl.lex_base[state + 1]
    if base < 0 then
      return -base - 1
    end

    -- Check if it's a backtrack point
    local backtrk = tbl.lex_backtrk[state + 1]
    if backtrk >= 0 then
      lexbuf[LEX_LAST_POS] = lexbuf[LEX_CURR_POS]
      lexbuf[LEX_LAST_ACTION] = backtrk
    end

    -- Check if we need a refill
    local c
    if lexbuf[LEX_CURR_POS] >= lexbuf[LEX_BUFFER_LEN] then
      if lexbuf[LEX_EOF_REACHED] == 0 then
        return -state - 1
      else
        c = 256  -- EOF pseudo-character
      end
    else
      -- Read next input char
      c = buffer[lexbuf[LEX_CURR_POS] + 1]
      lexbuf[LEX_CURR_POS] = lexbuf[LEX_CURR_POS] + 1
    end

    -- Determine next state
    if tbl.lex_check[base + c + 1] == state then
      state = tbl.lex_trans[base + c + 1]
    else
      state = tbl.lex_default[state + 1]
    end

    -- If no transition on this char, return to last backtrack point
    if state < 0 then
      lexbuf[LEX_CURR_POS] = lexbuf[LEX_LAST_POS]
      if lexbuf[LEX_LAST_ACTION] == -1 then
        error("lexing: empty token")
      else
        return lexbuf[LEX_LAST_ACTION]
      end
    else
      -- Erase the EOF condition only if the EOF pseudo-character was
      -- consumed by the automaton (i.e. there was no backtrack above)
      if c == 256 then
        lexbuf[LEX_EOF_REACHED] = 0
      end
    end
  end
end

-- Create a lexer buffer from a string
-- s: input string (Lua string or OCaml byte array)
-- Returns: lexbuf structure
--Provides: caml_create_lexbuf_from_string
function caml_create_lexbuf_from_string(s)
  -- Convert to byte array if it's a Lua string
  local buffer
  if type(s) == "string" then
    buffer = {string.byte(s, 1, -1)}
  else
    buffer = s
  end

  local lexbuf = {
    [LEX_REFILL_BUF] = nil,        -- Refill function (not used for string)
    [LEX_BUFFER] = buffer,          -- Input buffer (byte array)
    [LEX_BUFFER_LEN] = #buffer,     -- Buffer length
    [LEX_ABS_POS] = 0,              -- Absolute position in stream
    [LEX_START_POS] = 0,            -- Start of current token
    [LEX_CURR_POS] = 0,             -- Current position
    [LEX_LAST_POS] = 0,             -- Last backtrack position
    [LEX_LAST_ACTION] = -1,         -- Last backtrack action
    [LEX_EOF_REACHED] = 0,          -- EOF reached flag
    [LEX_MEM] = {},                 -- Memory for position tracking
    [LEX_START_P] = {               -- Start position info
      pos_fname = "",
      pos_lnum = 1,
      pos_bol = 0,
      pos_cnum = 0,
    },
    [LEX_CURR_P] = {                -- Current position info
      pos_fname = "",
      pos_lnum = 1,
      pos_bol = 0,
      pos_cnum = 0,
    },
  }

  return lexbuf
end

-- Create a lexer buffer from a channel
-- channel_id: channel identifier
-- Returns: lexbuf structure
--Provides: caml_create_lexbuf_from_channel
--Requires: caml_ml_input
function caml_create_lexbuf_from_channel(channel_id)

  -- Refill function that reads from channel
  local function refill_func(lexbuf)
    local buf_size = 1024
    local buffer = {}
    local n = caml_ml_input(channel_id, buffer, 0, buf_size)

    if n == 0 then
      lexbuf[LEX_EOF_REACHED] = 1
      return 0
    end

    lexbuf[LEX_BUFFER] = buffer
    lexbuf[LEX_BUFFER_LEN] = n
    lexbuf[LEX_CURR_POS] = 0

    return n
  end

  local lexbuf = {
    [LEX_REFILL_BUF] = refill_func,
    [LEX_BUFFER] = {},
    [LEX_BUFFER_LEN] = 0,
    [LEX_ABS_POS] = 0,
    [LEX_START_POS] = 0,
    [LEX_CURR_POS] = 0,
    [LEX_LAST_POS] = 0,
    [LEX_LAST_ACTION] = -1,
    [LEX_EOF_REACHED] = 0,
    [LEX_MEM] = {},
    [LEX_START_P] = {
      pos_fname = "",
      pos_lnum = 1,
      pos_bol = 0,
      pos_cnum = 0,
    },
    [LEX_CURR_P] = {
      pos_fname = "",
      pos_lnum = 1,
      pos_bol = 0,
      pos_cnum = 0,
    },
  }

  -- Initial fill
  refill_func(lexbuf)

  return lexbuf
end

-- Get lexeme as a string
-- lexbuf: lexer buffer
-- Returns: OCaml byte array (substring from start to current position)
--Provides: caml_lexeme
function caml_lexeme(lexbuf)
  local start_pos = lexbuf[LEX_START_POS]
  local curr_pos = lexbuf[LEX_CURR_POS]
  local buffer = lexbuf[LEX_BUFFER]
  local result = {}

  for i = start_pos + 1, curr_pos do
    result[#result + 1] = buffer[i]
  end

  return result
end

-- Get lexeme as Lua string
-- lexbuf: lexer buffer
-- Returns: Lua string
--Provides: caml_lexeme_string
--Requires: caml_lexeme
function caml_lexeme_string(lexbuf)
  local bytes = caml_lexeme(lexbuf)
  local chars = {}
  for i = 1, #bytes do
    chars[i] = string.char(bytes[i])
  end
  return table.concat(chars)
end

-- Get lexeme start position
-- lexbuf: lexer buffer
-- Returns: integer
--Provides: caml_lexeme_start
function caml_lexeme_start(lexbuf)
  return lexbuf[LEX_START_POS] + lexbuf[LEX_ABS_POS]
end

-- Get lexeme end position
-- lexbuf: lexer buffer
-- Returns: integer
--Provides: caml_lexeme_end
function caml_lexeme_end(lexbuf)
  return lexbuf[LEX_CURR_POS] + lexbuf[LEX_ABS_POS]
end

-- Get lexeme start position info
-- lexbuf: lexer buffer
-- Returns: position record
--Provides: caml_lexeme_start_p
function caml_lexeme_start_p(lexbuf)
  return lexbuf[LEX_START_P]
end

-- Get lexeme end position info (current position)
-- lexbuf: lexer buffer
-- Returns: position record
--Provides: caml_lexeme_end_p
function caml_lexeme_end_p(lexbuf)
  return lexbuf[LEX_CURR_P]
end

-- Update current position tracking for newline
-- lexbuf: lexer buffer
--Provides: caml_new_line
function caml_new_line(lexbuf)
  local curr_p = lexbuf[LEX_CURR_P]
  curr_p.pos_lnum = curr_p.pos_lnum + 1
  curr_p.pos_bol = lexbuf[LEX_CURR_POS] + lexbuf[LEX_ABS_POS]
  curr_p.pos_cnum = curr_p.pos_bol
end

-- Get character at specific position in lexeme
-- lexbuf: lexer buffer
-- n: position offset from start
-- Returns: character code
--Provides: caml_lexeme_char
function caml_lexeme_char(lexbuf, n)
  local pos = lexbuf[LEX_START_POS] + n
  if pos < lexbuf[LEX_CURR_POS] then
    return lexbuf[LEX_BUFFER][pos + 1]
  else
    error("lexeme_char: index out of bounds")
  end
end

-- Flush lexbuf buffer
-- lexbuf: lexer buffer
--Provides: caml_flush_lexbuf
function caml_flush_lexbuf(lexbuf)
  lexbuf[LEX_ABS_POS] = lexbuf[LEX_ABS_POS] + lexbuf[LEX_CURR_POS]
  lexbuf[LEX_CURR_POS] = 0
  lexbuf[LEX_START_POS] = 0
  lexbuf[LEX_LAST_POS] = 0
  lexbuf[LEX_BUFFER] = {}
  lexbuf[LEX_BUFFER_LEN] = 0
end
