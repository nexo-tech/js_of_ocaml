diff --git a/compiler/lib-lua/lua_generate.ml b/compiler/lib-lua/lua_generate.ml
index 4d25c6b5..ea8e31c6 100644
--- a/compiler/lib-lua/lua_generate.ml
+++ b/compiler/lib-lua/lua_generate.ml
@@ -2813,6 +2813,23 @@ and generate_last_dispatch ctx last =
           group_by_continuation conts
       in

+      (* Task 5.3k.1 FIX: Filter out Switch targets that don't exist in program.Code.blocks.
+         This fixes Printf %f hang where Switch references non-existent blocks (594, 595, 598-602).
+
+         Problem: collect_reachable silently skips non-existent blocks during traversal,
+         but generate_last_dispatch still generates `_next_block = addr` for them.
+         Result: Infinite loop when code sets _next_block to a value with no dispatch case.
+
+         Solution: Only generate dispatch for blocks that actually exist.
+         This matches JS behavior where non-existent Switch targets are effectively unreachable. *)
+      let grouped_filtered =
+        match ctx.program with
+        | None -> grouped  (* No program context - keep all (shouldn't happen) *)
+        | Some program ->
+            List.filter grouped ~f:(fun (addr, _args, _indices) ->
+              Code.Addr.Map.mem addr program.Code.blocks)
+      in
+
       (* Format string mapping from JS convert_int function (see test_simple.ml.pretty.js:7226)
          Maps case index to format string variable (v102="%d", v103="%+d", etc.) *)
       let get_format_string_var idx =
@@ -2834,7 +2851,7 @@ and generate_last_dispatch ctx last =
       in

       let cases =
-        List.map grouped ~f:(fun (addr, args, indices) ->
+        List.map grouped_filtered ~f:(fun (addr, args, indices) ->
             (* Build condition for all indices: var == i1 or var == i2 or ... *)
             let cond = build_multi_case_condition switch_var indices in
             (* Generate argument passing *)
